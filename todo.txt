basic unit of data is a piece
a piece has a type: (official, commission, fan-created)
a piece has tags
a piece can have upto 1 canonical media (txt, png, jpeg, etc)
a piece can have drafts
    a draft has a piece of media attached and some metadata
a piece can have raws
    a raw has a piece of media attached and some metadata
a piece can have variants
    a variant has a piece of media attached and some metadata
    each variant can have additional tags which are union'd with the piece's tags
a piece can have a price:
    a base price
    a tip

a media has
    a date added
    optionally a list of links to sources
    rating: safe, tasteful, explicit

basic tag info is
    a name
    a description

a tag when associated with piece has
    optionally a category

starting categories are:
    character:
    artist:
    (none):

categories have:
    a color
    a description
    


- implement multiple blob view for pieces
    - click to zoom
- implement double-right click back and forth navigation 
- implement saving data to disk
- move to message passing system
    ? still debating how to handle gui state, given some of it may make more sense to do later
- remove image tooltips, replace them with piece name (info?) tool tips
- reorg gui code
- implement adding blobs via an Add button in each category
- implement left right navigation when zoomed in on a blob
- abstract all relevant gui code pertaining to db items
- better image/thumbnail loading
- add multiple blob loading
    - handle undo checkpointing properly
- create date editor widget

v0.1 milestone
- implement saving images to files on disk rather than storing in one file
- switch to dates over datetimes for data?
- tooltips and help screen

v0.2 and beyond
- create blob editing
- create gui_stack, to move back and forth between locations [gallery, piece view, tag list, etc], where double right click pops off the stack
- implement adding tags
- implement editing tags
- implement viewing tag list
- implement categories
- implement searching
- image/thumbnail invalidation based on matching the hashes.




tag syntax:
tag = [a-zA-Z0-9_()-+]+

search syntax
search_list = item -> (" " -> item)*
item = grouped | or_list | single

single = modifiers? -> tag | date_added | price | source_type | media_type

source_type = "fan" | "official" | "commission"
media_type = "text" | "image"

price = price_op -> number
price_op = ">" | ">=" | ...

date_added = date_op -> date 
date_op = "before" | "after" | "on"

date = anything chrono can parse

modifiers = "-" 

or_list = single -> ("|" -> item)+

grouped = "(" -> search_list -> ")"

enum Condition {
    And(Vec<Condition>)
    Or(Vec<Condition>)
    Condition {
        negate: bool,
        test: Test,
    }
}

pub enum Test {
    Tag(Option<Category>, Tag),
    Source(SourceType),
    Media(MediaType),
    DateAdded(DateOp, DateTime<Local>),
    Price(PriceOp, u32),
}

