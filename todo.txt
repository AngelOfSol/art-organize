basic unit of data is a piece
a piece has a type: (official, commission, fan-created)
a piece has tags
a piece can have upto 1 canonical media (txt, png, jpeg, etc)
a piece can have drafts
    a draft has a piece of media attached and some metadata
a piece can have raws
    a raw has a piece of media attached and some metadata
a piece can have variants
    a variant has a piece of media attached and some metadata
    each variant can have additional tags which are union'd with the piece's tags
a piece can have a price:
    a base price
    a tip

a media has
    a date added
    optionally a list of links to sources
    rating: safe, tasteful, explicit

basic tag info is
    a name
    a description

a tag when associated with piece has
    optionally a category

starting categories are:
    character:
    artist:
    (none):

categories have:
    a color
    a description
    



consider putting app_state behind a Mutex, so the gui thread can write to it

put the DB behind an Arc<RwLock>?



undo history is saved on changes, for text boxes, its saved when item is deactivated_after_edit
whenever undo history is saved, underlying db should also be saved


piece/tag/blob data is edited inline
associations are farmed out to message passing, so constraints can be handled
ui state changes should be farmed out to message passing also

have to decide still on how to navigate between different view types
[tabs? view item in menu bar? side bar like tagspaces?]

also need to use a better locking scheme, so that searches can proceed unimpeded

todo, consider RwLockUpgradeable from parking lot


tag syntax:
tag = "tag" | "category:tag"

search syntax
search_list = item -> (" " -> item)*
item = grouped | or_list | single

single = modifiers? -> tag | date_added | price | source_type | media_type

source_type = "fan" | "official" | "commission"
media_type = "text" | "image"

price = price_op -> number
price_op = ">" | ">=" | ...

date_added = date_op -> (date | date_time)
date_op = "before" | "after" | "on"

date = anything chrono can parse
date_time = anything chrono can parse

modifiers = "-" 

or_list = single -> ("|" -> item)+

grouped = "(" -> search_list -> ")"

enum Condition {
    And(Vec<Condition>)
    Or(Vec<Condition>)
    Condition {
        negate: bool,
        test: Test,
    }
}

pub enum Test {
    Tag(Option<Category>, Tag),
    Source(SourceType),
    Media(MediaType),
    DateAdded(DateOp, DateTime<Local>),
    Price(PriceOp, u32),
}

