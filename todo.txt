basic unit of data is a piece
a piece has a type: (official, commission, fan-created)
a piece has tags
a piece can have upto 1 canonical media (txt, png, jpeg, etc)
a piece can have drafts
    a draft has a piece of media attached and some metadata
a piece can have raws
    a raw has a piece of media attached and some metadata
a piece can have variants
    a variant has a piece of media attached and some metadata
    each variant can have additional tags which are union'd with the piece's tags
a piece can have a price:
    a base price
    a tip

a media has
    a date added
    optionally a list of links to sources
    rating: safe, tasteful, explicit

basic tag info is
    a name
    a description

a tag when associated with piece has
    optionally a category

starting categories are:
    character:
    artist:
    (none):

categories have:
    a color
    a description
    


- implement multiple blob view for pieces
    - click to zoom
- implement double-right click back and forth navigation 
- implement saving data to disk
- move to message passing system
    ? still debating how to handle gui state, given some of it may make more sense to do later
- remove image tooltips, replace them with piece name (info?) tool tips
- reorg gui code
- implement adding blobs via an Add button in each category
- implement left right navigation when zoomed in on a blob
- abstract all relevant gui code pertaining to db items


- implement saving images to files on disk rather than storing in one file
- better image/thumbnail loading
    - including invalidation
        - save hashes with the entries in the hashmap, and periodically check them to make sure they match?
- create blob editing
- create gui_stack, to move back and forth between locations [gallery, piece view, tag list, etc], where double right click pops off the stack
- implement adding tags
- implement editing tags
- implement viewing tag list
- implement categories
- implement searching



consider putting app_state behind a Mutex, so the gui thread can write to it

put the DB behind an Arc<RwLock>?

define right click to move up and down the hierachy

in the piece itself, when expanding the view of an image, left and right arrow buttons should iterate through the available blob_ids for that category

piece gallery:


drag and drop from explorer onto the sections to add

ui.text(Canon);
ui.separator;
ui.image repeatedly for each canon image

ui.text(Variant)
ui.separator;
etc....



undo history is saved on changes, for text boxes, its saved when item is deactivated_after_edit
whenever undo history is saved, underlying db should also be saved


piece/tag/blob data is edited inline
associations are farmed out to message passing, so constraints can be handled
ui state changes should be farmed out to message passing also

have to decide still on how to navigate between different view types
[tabs? view item in menu bar? side bar like tagspaces?]

also need to use a better locking scheme, so that searches can proceed unimpeded

todo, consider RwLockUpgradeable from parking lot


tag syntax:
tag = "tag" | "category:tag"

search syntax
search_list = item -> (" " -> item)*
item = grouped | or_list | single

single = modifiers? -> tag | date_added | price | source_type | media_type

source_type = "fan" | "official" | "commission"
media_type = "text" | "image"

price = price_op -> number
price_op = ">" | ">=" | ...

date_added = date_op -> (date | date_time)
date_op = "before" | "after" | "on"

date = anything chrono can parse
date_time = anything chrono can parse

modifiers = "-" 

or_list = single -> ("|" -> item)+

grouped = "(" -> search_list -> ")"

enum Condition {
    And(Vec<Condition>)
    Or(Vec<Condition>)
    Condition {
        negate: bool,
        test: Test,
    }
}

pub enum Test {
    Tag(Option<Category>, Tag),
    Source(SourceType),
    Media(MediaType),
    DateAdded(DateOp, DateTime<Local>),
    Price(PriceOp, u32),
}

